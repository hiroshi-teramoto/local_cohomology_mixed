LIB "teachstd.lib";
LIB "polylib.lib";
LIB "ainvar.lib";
LIB "crypto.lib";
LIB "zeroset.lib";
LIB "redcgs.lib";

LIB "addcons.lib";
LIB "inverse_ring.lib";
LIB "associative_container.lib";
newstruct("ass_con","list keys, list values");
LIB "related_terms.lib";
LIB "local_cohomology_mixed.lib";

LIB "cgs.lib";
LIB "check_zeros.lib";
LIB "simplify_constructible.lib";
LIB "combine_locally_closed.lib";

int nx = 4;
int ny = 4;
int i,j,k,l;

// ring R = 0, (x(1..nx),y(1..ny)), (ls,c);
ring R = 0, (x(1..nx),y(1..ny)), (ws(1,1,1,1,1,1,2,2),c);
list X = list();
X[1] = ideal(y(1),y(2),y(3),y(4));

ideal E = 0;
ideal N = 1;

poly f(1..ny);
f(1) = x(1);
f(2) = x(2);
f(3) = x(3)*x(4);
f(4) = x(3)^2-x(4)^2+x(1)*x(3)+x(2)*x(4);

vector f;
for(i=1;i<=ny;i++){
	f = f + f(i)*gen(i);
}

ideal zero;
for(i=1;i<=ny;i++){
	zero = zero, y(i)-f[i];
}
zero = compress(zero);
module TR;
for(i=1;i<=nx;i++){
	TR = TR, diff(f,x(i));
}
TR = compress(TR);
ideal mx = x(1..nx);
ideal my = y(1..ny);

int K = 3;
module TR1K = TR + zero*freemodule(ny) + mx^(K+1)*freemodule(ny);

// Q[i]: generators of component X_{i+1} in the paper, which is X[i]-module
list Q;
Q[1] = module(gen(1),gen(2),gen(3),gen(4));

// option(prot);
system("--ticks-per-sec",1000);
rtimer=1;
int t=rtimer;
list Lg = local_cohomology_mixed_s(X,E,N,TR1K,Q);
rtimer-t;

for(i=1;i<=size(Lg);i++){
	Lg[i][1] = radical_ideal(Lg[i][1]);
	Lg[i][2] = radical_ideal(Lg[i][2]);
}

for(i=1;i<=size(Lg);i++){
	print("E :");
	Lg[i][1];
	print("N :");
	Lg[i][2];
	print("quotients :");
	kbase_mixed(Lg[i][3]);
}

quit;
